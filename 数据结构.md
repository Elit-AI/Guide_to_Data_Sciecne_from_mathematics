# 数据结构

数据结构是计算机中存储、组织数据的方式。
数据结构包括数据值和数据的操作。

- https://zhuanlan.zhihu.com/p/38194127
- https://cs.uwaterloo.ca/~imunro/Durhamo4.ppt
- http://www.lirmm.fr/mastodons/talks/Gog-indexing-2014.pdf
- http://www.eecs.tufts.edu/~aloupis/comp150/topics.html
- http://stevehanov.ca/blog/?id=120
- https://arxiv.org/abs/1902.09228
- http://www-erato.ist.hokudai.ac.jp/alsip2012/
- https://www.cise.ufl.edu/~sgchen/Research.html
- https://users.dcc.uchile.cl/~gnavarro/
- https://users.dcc.uchile.cl/~gnavarro/publ.html





## 数据结构

- (1) 数据模型。数据特征的抽象，用来描述问题。
- (2) 数据结构。用来表示数据模型的编程语言结构。例如，C语言提供了内置的抽象，比如 结构和指针，使我们能够构建数据结构，表示像图这类的复杂抽象。
- (3) 算法。操作用数据模型抽象、数据结构等形式表示的数据，从而获取解决方案的技术。

任何数学概念都可称为数据模型。而在计算机科学领域，数据模型通常包含以下两个方面。
* (1) 对象可以采用的值。例如，很多数据模型包含具有整数值的对象。数据模型的这个方面是静态的，它告诉我们对象能接受哪些值。编程语言数据模型的这一静态部分通常被称为类型系统。
* (2) 数据的运算。例如，我们常常会对整数执行加法这样的运算。模型的这一方面是动态的，它告诉我们改变值和创建新值的方式。

每种编程语言都有自己的数据模型，这些数据模型互不相同，而且通常有相当大的差异。
多数编程语言处理数据所遵循的基本原则是，每个程序都可以访问我们用于表示存储区域的“框”。
每个框都具有一个类型，比如int或char。框中可以存储类型对应的值，通常将可以存储到这些框中的值称为数据对象。

- http://soong.site/datastructure/

### Python中的数据结构

Python中的基本数据结构包括：
- 列表，list;
- 元组，tuple;
- 集合， set;
- 字典， dict;
- 字符串， str;
- 数值。

Python3 的六个标准数据类型中：

* 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；
* 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。

#### 标识符

Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。

在 Python 中，变量就是变量，它没有类型，我们所说的"类型"是变量所指的内存中对象的类型。
等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。
del 也可以被用来删除整个变量。

Python中的标识符是大小写敏感的。所以temperature 和 Temperature 并不相同. 标识符可以由字母、数字和下划线 (或更广义的 Unicode 字符)组成. 
主要的限制是标识符不能以数字开头(因此 9lives不是一个有效的标识符), 并且保留字不能作为标识符，如下：

|Reserved Words|
|--------------|
|False as continue else from in not return yield|
|None assert def except global is or try|
|True break del finally if lambda pass while|
|and class elif for import nonlocal raise with|



- https://www.runoob.com/python3/python3-data-structure.html
- https://docs.python.org/zh-cn/3/tutorial/datastructures.html
- https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/

### 数值

Python3 支持 `int、float、bool、complex`（复数）。
int| float | bool |complex
---|-------|------|------
12 | 1.2   | True/False| 1+7j

```
#!/usr/bin/python3
 
a, b, c, d = 20, 5.5, True, 4+3j

print(a, b, c, d, a+b, a-b, a*b, a/b, a//3, a**2)

```

### 列表

timeit.Timer.timeit(number=1000000)
Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的耗时，一个float类型的秒数。
```
def t1():
   l = []
   for i in range(1000):
      l = l + [i]
def t2():
   l = []
   for i in range(1000):
      l.append(i)
def t3():
   l = [i for i in range(1000)]
def t4():
   l = list(range(1000))

from timeit import Timer

timer1 = Timer("t1()", "from __main__ import t1")
print("concat ",timer1.timeit(number=1000), "seconds")
timer2 = Timer("t2()", "from __main__ import t2")
print("append ",timer2.timeit(number=1000), "seconds")
timer3 = Timer("t3()", "from __main__ import t3")
print("comprehension ",timer3.timeit(number=1000), "seconds")
timer4 = Timer("t4()", "from __main__ import t4")
print("list range ",timer4.timeit(number=1000), "seconds")
```

列表的更多特性|---
----|-----
list.append(x)|在列表的末尾添加一个元素。相当于 a[len(a):] = [x] 。
list.extend(iterable)|使用可迭代对象中的所有元素来扩展列表。相当于 a[len(a):] = iterable 。
list.insert(i, x)|在给定的位置插入一个元素。第一个参数是要插入的元素的索引，所以 a.insert(0, x) 插入列表头部， a.insert(len(a), x) 等同于 a.append(x) 。
list.remove(x)|移除列表中第一个值为 x 的元素。如果没有这样的元素，则抛出 ValueError 异常。
list.pop([i])|删除列表中给定位置的元素并返回它。如果没有给定位置，a.pop() 将会删除并返回列表中的最后一个元素。（ 方法签名中 i 两边的方括号表示这个参数是可选的，而不是要你输入方括号。你会在 Python 参考库中经常看到这种表示方法)。
list.clear()|删除列表中所有的元素。相当于 del a[:] 。
list.index(x[, start[, end]])|返回列表中第一个值为 x 的元素的从零开始的索引。如果没有这样的元素将会抛出 ValueError 异常。可选参数 start 和 end 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 start 参数。
list.count(x)|返回元素 x 在列表中出现的次数。
list.sort(key=None, reverse=False)|对列表中的元素进行排序（参数可用于自定义排序，解释请参见 sorted()）。
list.reverse()|反转列表中的元素。
list.copy()|返回列表的一个浅拷贝。相当于 a[:] 


列表推导式的结构是由一对方括号所包含的以下内容：一个表达式，后面跟一个 for 子句，然后是零个或多个 for 或 if 子句。 其结果将是一个新列表，由对表达式依据后面的 for 和 if 子句的内容进行求值计算而得出。 举例来说，以下列表推导式会将两个列表中不相等的元素组合起来:
```
[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
```
列表推导式中的初始表达式可以是任何表达式，包括另一个列表推导式。

考虑下面这个 3x4的矩阵，它由3个长度为4的列表组成
```
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
 ]
```
下面的列表推导式将交换其行和列
```
[[row[i] for row in matrix] for i in range(4)]
```

del 语句也可以用来从列表中移除切片或者清空整个列表（我们之前用过的方式是将一个空列表赋值给指定的切片）。 例如:
```
del a[0] #a变为 [1, 66.25, 333, 333, 1234.5]
del a[2:4] #a变为 [1, 66.25, 1234.5]
del a[:] # a变为[]
```


### 元组和序列

我们看到列表和字符串有很多共同特性，例如索引和切片操作。他们是 序列 数据类型（参见 [序列类型 --- list, tuple, range](https://docs.python.org/zh-cn/3/library/stdtypes.html#typesseq)）中的两种。随着 Python 语言的发展，其他的序列类型也会被加入其中。这里介绍另一种标准序列类型: 元组。

元组在输出时总是被圆括号包围的，以便正确表示嵌套元组。输入时圆括号可有可无，不过经常会是必须的（如果这个元组是一个更大的表达式的一部分）。给元组中的一个单独的元素赋值是不允许的，当然你可以创建包含可变对象的元组，例如列表。

虽然元组可能看起来与列表很像，但它们通常是在不同的场景被使用，并且有着不同的用途。元组是 immutable （不可变的），其序列通常包含不同种类的元素，并且通过解包（这一节下面会解释）或者索引来访问（如果是 namedtuples 的话甚至还可以通过属性访问）。列表是 mutable （可变的），并且列表中的元素一般是同种类型的，并且通过迭代访问。

一个特殊的问题是构造包含0个或1个元素的元组：为了适应这种情况，语法有一些额外的改变。空元组可以直接被一对空圆括号创建，含有一个元素的元组可以通过在这个元素后添加一个逗号来构建（圆括号里只有一个值的话不够明确）。丑陋，但是有效。例如
```
empty = ()
singleton = 'hello',    # <-- note trailing comma
print(len(empty),
len(singleton),
singleton)
```

语句 t = 12345, 54321, 'hello!' 是 `元组打包` 的一个例子：值 12345, 54321 和 'hello!' 被打包进元组。其逆操作也是允许的
`x, y, z = t`
这被称为 `序列解包` 也是很恰当的，因为解包操作的等号右侧可以是任何序列。序列解包要求等号左侧的变量数与右侧序列里所含的元素数相同。注意多重赋值其实也只是元组打包和序列解包的组合.

有三种基本序列类型：list, tuple 和 range 对象。 为处理 二进制数据 和 文本字符串 而特别定制的附加序列类型会在专门的小节中描述。

通用序列操作
大多数序列类型，包括可变类型和不可变类型都支持下表中的操作。 collections.abc.Sequence ABC 被提供用来更容易地在自定义序列类型上正确地实现这些操作。

此表按优先级升序列出了序列操作。 在表格中，s 和 t 是具有相同类型的序列，n, i, j 和 k 是整数而 x 是任何满足 s 所规定的类型和值限制的任意对象。

in 和 not in 操作具有与比较操作相同的优先级。 + (拼接) 和 * (重复) 操作具有与对应数值运算相同的优先级。 3

运算|结果
----|---
x in s    |如果 s 中的某项等于 x 则结果为 True，否则为 False
x not in s|如果 s 中的某项等于 x 则结果为 False，否则为 True
s + t     |s 与 t 相拼接
s * n 或 n * s|相当于 s 与自身进行 n 次拼接
s[i]|s 的第 i 项，起始为 0
s[i:j]|s 从 i 到 j 的切片
s[i:j:k]|s 从 i 到 j 步长为 k 的切片
len(s)|s 的长度
min(s)|s 的最小项
max(s)|s 的最大项
s.index(x[, i[, j]])|x 在 s 中首次出现项的索引号（索引号在 i 或其后且在 j 之前）
s.count(x)|x 在 s 中出现的总次数

### 集合

Python也包含有 集合 类型。集合是由不重复元素组成的无序的集。它的基本用法包括成员检测和消除重复元素。集合对象也支持像 联合，交集，差集，对称差分等数学运算。

花括号或 set() 函数可以用来创建集合。注意：要创建一个空集合你只能用 set() 而不能用 {}，因为后者是创建一个空字典，这种数据结构我们会在下一节进行讨论。

创建一个集合：
```
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
a = set('abracadabra')#利用set将字符串转化为集合
a = {x for x in 'abracadabra' if x not in 'abc'} #推导式
```
集合的运算

```
a = set('abracadabra')
b = set('alacazam')
a - b      # 在 a 中的字母，但不在 b 中,{'r', 'd', 'b'}
a | b      # 在 a 或 b 中的字母,{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
a & b      # 在 a 和 b 中都有的字母, {'a', 'c'}
a ^ b      # 在 a 或 b 中的字母，但不同时在 a 和 b 中,{'r', 'd', 'b', 'm', 'z', 'l'}
```

### 字典


理解字典的最好方式，就是将它看做是一个 键: 值 对的集合，键必须是唯一的（在一个字典中）。一对花括号可以创建一个空字典：{} 。另一种初始化字典的方式是在一对花括号里放置一些以逗号分隔的键值对，而这也是字典输出的方式。

字典主要的操作是使用关键字存储和解析值。也可以用 del 来删除一个键值对。如果你使用了一个已经存在的关键字来存储值，那么之前与这个关键字关联的值就会被遗忘。用一个不存在的键来取值则会报错。

对一个字典执行 list(d) 将返回包含该字典中所有键的列表，按插入次序排列 (如需其他排序，则要使用 sorted(d))。要检查字典中是否存在一个特定键，可使用 in 关键字。

```
tel = {'jack': 4098, 'sape': 4139}#创建一个字典
tel['guido'] = 4127 #赋值
tel['jack'] #读取值
del tel['sape'] #删除键
```

dict() 构造函数可以直接从键值对序列里创建字典。
此外，字典推导式可以从任意的键值表达式中创建字典
```
{x: x**2 for x in (2, 4, 6)}
```

当关键字是简单字符串时，有时直接通过关键字参数来指定键值对更方便

`dict(sape=4139, guido=4127, jack=4098)`

- https://python3-cookbook.readthedocs.io/zh_CN/latest/c01/p08_calculating_with_dict.html
  
为了对字典值执行计算操作，通常需要使用 zip() 函数先将键和值反转过来。 比如，下面是查找最小和最大股票价格和股票值的代码：
```
prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}
min_price = min(zip(prices.values(), prices.keys()))
# min_price is (10.75, 'FB')
max_price = max(zip(prices.values(), prices.keys()))
# max_price is (612.78, 'AAPL')
min_value = prices[min(prices, key=lambda k: prices[k])]
```

#### 字符串

字符串是 Python 中最常用的数据类型。我们可以使用引号('或")来创建字符串。
创建字符串很简单，只要为变量分配一个值即可。

Python 中三引号可以将复杂的字符串进行赋值。
Python 三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。

三引号的语法是一对连续的单引号或者双引号（通常都是成对的用）。

些方法实现了string模块的大部分方法，如下表所示列出了目前字符串内建支持的方法，所有的方法都包含了对Unicode的支持，有一些甚至是专门用于Unicode的。

方法|描述
---|---
string.capitalize()|把字符串的第一个字符大写
string.center(width)|返回一个原字符串居中,并使用空格填充至长度 width 的新字符串
string.count(str, beg=0, end=len(string))|返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数
string.decode(encoding='UTF-8', errors='strict')|以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 'ignore' 或 者'replace'
string.encode(encoding='UTF-8', errors='strict')|以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace'
string.endswith(obj, beg=0, end=len(string))|检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.
string.expandtabs(tabsize=8)|把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。
string.find(str, beg=0, end=len(string))|检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1
string.format()|格式化字符串
string.index(str, beg=0, end=len(string))|跟find()方法一样，只不过如果str不在 string中会报一个异常.
string.isalnum()|如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False
string.isalpha()|如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False
string.isdecimal()|如果 string 只包含十进制数字则返回 True 否则返回 False.
string.isdigit()|如果 string 只包含数字则返回 True 否则返回 False.
string.islower()|如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False
string.isnumeric()|如果 string 中只包含数字字符，则返回 True，否则返回 False
string.isspace()|如果 string 中只包含空格，则返回 True，否则返回 False.
string.istitle()|如果 string 是标题化的(见 title())则返回 True，否则返回 False
string.isupper()|如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False
string.join(seq)|以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串
string.ljust(width)|返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串
string.lower()|转换 string 中所有大写字符为小写.
string.lstrip()|截掉 string 左边的空格
string.maketrans(intab, outtab])|maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。
max(str)|返回字符串 str 中最大的字母。
min(str)|返回字符串 str 中最小的字母。
string.partition(str)|有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string.
string.replace(str1, str2,  num=string.count(str1))|把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.
string.rfind(str, beg=0,end=len(string) )|类似于 find()函数，不过是从右边开始查找.
string.rindex( str, beg=0,end=len(string))|类似于 index()，不过是从右边开始.
string.rjust(width)|返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串
string.rpartition(str)|类似于 partition()函数,不过是从右边开始查找
string.rstrip()|删除 string 字符串末尾的空格.
string.split(str="", num=string.count(str))|以 str 为分隔符切片 string，如果 num 有指定值，则仅分隔 num+ 个子字符串
string.splitlines([keepends])|按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。
string.startswith(obj, beg=0,end=len(string))|检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查.
string.strip([obj])|在 string 上执行 lstrip()和 rstrip()
string.swapcase()|翻转 string 中的大小写
string.title()|返回"标题化"的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())
string.translate(str, del="")|根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中
string.upper()|转换 string 中的小写字母为大写
string.zfill(width)|返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0

#### 遍历

当在字典中循环时，用 items() 方法可将关键字和对应的值同时取出
```
knights = {'gallahad': 'the pure', 'robin': 'the brave'}
for k, v in knights.items():
    print(k, v)
```

当在序列中循环时，用 enumerate() 函数可以将索引位置和其对应的值同时取出
```
for i, v in enumerate(['tic', 'tac', 'toe']):
    print(i, v)
```

当同时在两个或更多序列中循环时，可以用 zip() 函数将其内元素一一匹配。

```
questions = ['name', 'quest', 'favorite color']
answers = ['lancelot', 'the holy grail', 'blue']
for q, a in zip(questions, answers):
    print('What is your {0}?  It is {1}.'.format(q, a))
```

当逆向循环一个序列时，先正向定位序列，然后调用 reversed() 函数
```
for i in reversed(range(1, 10, 2)):
    print(i)
```

如果要按某个指定顺序循环一个序列，可以用 sorted() 函数，它可以在不改动原序列的基础上返回一个新的排好序的序列

```
basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
for f in sorted(set(basket)):
    print(f)

```

有时可能会想在循环时修改列表内容，一般来说改为创建一个新列表是比较简单且安全的

```
import math
raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
filtered_data = []
for value in raw_data:
    if not math.isnan(value):
        filtered_data.append(value)

filtered_data
```


任何的序列（或者是可迭代对象）可以通过一个简单的赋值语句解压并赋值给多个变量。 唯一的前提就是变量的数量必须跟序列元素的数量是一样的。

## 输入与输出

首先，有这样一个层级关系，print和raw_input这样的高级命令调用的是sys.stdin和sys.stdout，而sys.stdin和sys.stdout是file like object（类似于linux中一切设备皆文件），这一层的实现是Python的io模块。

io分三种类型：text I/O、binary I/O、raw I/O。

1. text I/O顾名思义，就是对我们人类来说能看到的、能识别的文字数据。
2. binary I/O就是指所有非文本信息了，这类数据无需编码解码，也不用处理换行符，比如图片文件等。这个类型对应的open里的打开模式'b'。
3. 原始 I/O（也称为 非缓冲 I/O）通常用作二进制和文本流的低级构建块。用户代码直接操作原始流的用法非常罕见。不过，可以通过在禁用缓冲的情况下以二进制模式打开文件来创建原始流。

- https://docs.python.org/zh-cn/3/tutorial/inputoutput.html
- http://cs50mu.github.io/blog/2014/10/07/io-in-python/
- https://docs.python.org/zh-cn/3.9/library/io.html

### 输出

#### print

以下是 print() 方法的语法:
```
print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)
```
参数
* objects -- 复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。
* sep -- 用来间隔多个对象，默认值是一个空格。
* end -- 用来设定以什么结尾。默认值是换行符 \n，我们可以换成其他字符串。
* file -- 要写入的文件对象。
* flush -- 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新

- https://www.runoob.com/w3cnote/python3-print-func-b.html
- https://realpython.com/python-print/

pprint 模块提供了“美化打印”任意 Python 数据结构的功能，这种美化形式可用作对解释器的输入。 如果经格式化的结构包含非基本 Python 类型的对象，则其美化形式可能无法被加载。 包含文件、套接字或类对象，以及许多其他不能用 Python 字面值来表示的对象都有可能导致这样的结果。

- https://docs.python.org/zh-cn/3/library/pprint.html

可以使用在 print() 函数中使用 sep 和 end 关键字参数，以你想要的方式输出。比如：
```
print('ACME', 50, 91.5)
#ACME 50 91.5
print('ACME', 50, 91.5, sep=',')
#ACME,50,91.5
print('ACME', 50, 91.5, sep=',', end='!!\n')
#ACME,50,91.5!!
```
- https://python3-cookbook.readthedocs.io/zh_CN/latest/c05/p03_print_with_different_separator_or_line_ending.html

#### 字符串输出
对于基本的字符串对齐操作，可以使用字符串的 ljust() , rjust() 和 center() 方法。比如：
```
text = 'Hello World'
text.ljust(20)    #'Hello World         '
text.rjust(20)    #'         Hello World'
text.center(20)   #'    Hello World     '
```

要使用 格式化字符串字面值 ，请在字符串的开始引号或三引号之前加上一个 f 或 F 。在此字符串中，你可以在 { 和 } 字符之间写可以引用的变量或字面值的 Python 表达式。

```
year = 2016
event = 'Referendum'
f'Results of the {year} {event}'
#'Results of the 2016 Referendum'
```

当你不需要花哨的输出而只是想快速显示某些变量以进行调试时，可以使用 `repr()` or `str()` 函数将任何值转化为字符串。

`str()` 函数是用于返回人类可读的值的表示，而 `repr()` 是用于生成解释器可读的表示（如果没有等效的语法，则会强制执行 SyntaxError）对于没有人类可读性的表示的对象， `str()` 将返回和 `repr()` 一样的值。很多值使用任一函数都具有相同的表示，比如数字或类似列表和字典的结构。特殊的是字符串有两个不同的表示。

Python并没有对在字符串中简单替换变量值提供直接的支持。 但是通过使用字符串的 format() 方法来解决这个问题。比如：
```
s = '{name} has {n} messages.'
s.format(name='Guido', n=37)
```

函数 format() 同样可以用来很容易的对齐字符串。 你要做的就是使用 <,> 或者 ^ 字符后面紧跟一个指定的宽度。比如：
```
format(text, '>20')#'         Hello World'
format(text, '<20')#'Hello World         '
format(text, '^20')#'    Hello World     '
```

str.format() 的基本使用如下:
```
print('{}网址： "{}!"'.format('菜鸟教程', 'www.runoob.com'))
#菜鸟教程网址： "www.runoob.com!"
```
括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。

在括号中的数字用于指向传入对象在 format() 中的位置，如下所示：
```
print('{0} 和 {1}'.format('Google', 'Runoob'))
#Google 和 Runoob
print('{1} 和 {0}'.format('Google', 'Runoob'))
#Runoob 和 Google
```
如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。
```
print('{name}网址： {site}'.format(name='菜鸟教程', site='www.runoob.com'))
#菜鸟教程网址： www.runoob.com
```
位置及关键字参数可以任意的结合:
```
print('站点列表 {0}, {1}, 和 {other}。'.format('Google', 'Runoob', other='Taobao'))
#站点列表 Google, Runoob, 和 Taobao。
```
!a (使用 ascii()), !s (使用 str()) 和 !r (使用 repr()) 可以用于在格式化某个值之前对其进行转化:
```
import math
print('常量 PI 的值近似为： {}。'.format(math.pi))
#常量 PI 的值近似为： 3.141592653589793。
print('常量 PI 的值近似为： {!r}。'.format(math.pi))
#常量 PI 的值近似为： 3.141592653589793。
```
可选项 : 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位：
```
import math
print('常量 PI 的值近似为 {0:.3f}。'.format(math.pi))
#常量 PI 的值近似为 3.142。
```
在 : 后传入一个整数, 可以保证该域至少有这么多的宽度。 用于美化表格时很有用。
```
table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
for name, number in table.items():
   print('{0:10} ==> {1:10d}'.format(name, number))

#Google     ==>          1
#Runoob     ==>          2
#Taobao     ==>          3
```
如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。

最简单的就是传入一个字典, 然后使用方括号 [] 来访问键值 :
```
table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
print('Runoob: {0[Runoob]:d}; Google: {0[Google]:d}; Taobao: {0[Taobao]:d}'.format(table))
#Runoob: 2; Google: 1; Taobao: 3
```
也可以通过在 table 变量前使用 ** 来实现相同的功能：

```
table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
print('Runoob: {Runoob:d}; Google: {Google:d}; Taobao: {Taobao:d}'.format(**table))
#Runoob: 2; Google: 1; Taobao: 3
```   
- https://docs.python.org/zh-cn/3/tutorial/inputoutput.html
- https://www.runoob.com/python3/python3-inputoutput.html
- https://python3-cookbook.readthedocs.io/zh_CN/latest/c02/p15_interpolating_variables_in_strings.html

使用`textwrap`模块来格式化字符串的输出。比如，假如你有下列的长字符串：

s = "Look into my eyes, look into my eyes, the eyes, the eyes, \
the eyes, not around the eyes, don't look around the eyes, \
look into my eyes, you're under."
```
import textwrap
print(textwrap.fill(s, 70))
#Look into my eyes, look into my eyes, the eyes, the eyes, the eyes,
#not around the eyes, don't look around the eyes, look into my eyes,
#you're under.
```

- https://docs.python.org/3.6/library/textwrap.html#textwrap.TextWrapper


### 输入



- https://www.runoob.com/python/python-func-input.html
- https://www.runoob.com/python3/python3-func-input.html
- https://www.runoob.com/w3cnote/python2-python3-raw_input-and-input.html

#### input

Python3.x 中 input() 函数接受一个标准输入数据，返回为 string 类型。

Python2.x 中 input() 相等于 eval(raw_input(prompt)) ，用来获取控制台的输入。

raw_input() 将所有输入作为字符串看待，返回字符串类型。而 input() 在对待纯数字输入时具有自己的特性，它返回所输入的数字的类型（ int, float ）。

#### sys.stdin

Stdin 代表标准输入流，程序从标准输入流开始读取输入的数据。
它与input()有一点区别，也就是stdin也去读用户键入的escape字符。并且stdin也提供了一个参数来表示一次要读取的字符数。
```
import sys

while True:
    try:
        line = sys.stdin.readline()
    except KeyboardInterrupt:
        break

    if not line:
        break

    print(line)
```

input()方法和stdin()类似，不同的是input()括号内可以直接填写说明文字。
可以看一个简单的例子：
```
while True:
    n = int(input('Please input a number:\n'))
    sn = list(map(int,input('Please input some numbers:\n').split()))
    print(n)
    print(sn,'\n')。
#原文链接：https://blog.csdn.net/CAU_Ayao/java/article/details/81985103
```
python3中使用sys.stdin.readline()可以实现标准输入，其中默认输入的格式是字符串，如果是int，float类型则需要强制转换。
```
name = sys.stdin.readline() 
print(name) 
  
num = sys.stdin.readline(2) 
print(num) 
```

- https://www.codenong.com/1450393/
- https://www.programcreek.com/python/example/52597/sys.stdout.write



### 文件读写

使用带有 rt 模式的 open() 函数读取文本文件。如下所示：

```
# Read the entire file as a single string
with open('somefile.txt', 'rt') as f:
    data = f.read()

# Iterate over the lines of the file
with open('somefile.txt', 'rt') as f:
    for line in f:
        # process line
        ...
```
类似的，为了写入一个文本文件，使用带有 wt 模式的 open() 函数， 如果之前文件内容存在则清除并覆盖掉。如下所示：
```
# Write chunks of text data
with open('somefile.txt', 'wt') as f:
    f.write(text1)
    f.write(text2)
    ...

# Redirected print statement
with open('somefile.txt', 'wt') as f:
    print(line1, file=f)
    print(line2, file=f)
    ...
``` 
如果是在已存在文件中添加内容，使用模式为 at 的 open() 函数。

文件的读写操作默认使用系统编码，可以通过调用 sys.getdefaultencoding() 来得到。 在大多数机器上面都是utf-8编码。如果你已经知道你要读写的文本是其他编码方式， 那么可以通过传递一个可选的 encoding 参数给open()函数。如下所示：
```
with open('somefile.txt', 'rt', encoding='latin-1') as f:
    ...
```

读写文本文件一般来讲是比较简单的。但是也几点是需要注意的。 首先，在例子程序中的with语句给被使用到的文件创建了一个上下文环境， 但 with 控制块结束时，文件会自动关闭。你也可以不使用 with 语句，但是这时候你就必须记得手动关闭文件：
```
f = open('somefile.txt', 'rt')
data = f.read()
f.close()
```

- https://python3-cookbook.readthedocs.io/zh_CN/latest/chapters/p05_files_and_io.html

## 排序

`sort()` 是Python列表的一个内置的排序方法，list.sort() 方法排序时直接修改原列表，返回None；

`sorted()` 是Python内置的一个排序函数，它会从一个迭代器返回一个排好序的新列表。

相比于 `sort()`，`sorted()` 使用的范围更为广泛，但是如果不需要保留原列表，sort更有效一点。另外，sort() 只是列表的一个方法，只适用于列表，而sorted() 函数接受一切迭代器，返回新列表。
两者的函数形式分别如下（Python3.5.2）：
```
sorted(iterable[, key][, reverse]) 
list.sort(*, key=None, reverse=None)
``` 
这两个方法有以下 2 个共同的参数：

* key 是带一个参数的函数，返回一个值用来排序，默认为 None。这个函数只调用一次，所以fast。
* reverse 表示排序结果是否反转

sorted() 函数功能非常强大，它可以方便地针对不同的数据结构进行排序，从而满足不同需求。

- https://www.jianshu.com/p/7be04a3f30cd
- https://www.runoob.com/w3cnote/ten-sorting-algorithm.html

## 紧凑数据结构

[本课程教授用于处理大数据（尤其是网络大数据）的紧凑数据结构及相应的算法、概率方法和统计工具。]((http://net.pku.edu.cn/~yangtong/pages/SummerForm18.html)) 
目前最大的大数据或许就是因特网上的数据流了。 对这个大数据的分析能为提高网络性能、网络应用的用户体验及网络安全提供理论基础。
然而网络大数据无法保留。 
在这个背景下，本课程讲授一系列在过去30年里逐渐发展起来的紧凑数据结构和它们的理论分析，
这些数据结构可以用来把大数据变小，以便于存储和应用。 
本课程的数据结构和算法可以分为两类：

1.  计数与计模，包括probabilistic counting, bitmap algorithms, FM sketch, hyperloglog sketch, virtual bitmap, virutal FM sketch, virtual hyperloglog, countMin, counter braids, randomized counter sharing, and virtual counters；
2. 成员查找与分类，包括Bloom filters, counting Bloom filters, Bloomier filters, blocked Bloom filters, multi-set filters, and multi-hashing tables。 学生不但将掌握这些数据结构和算法，而且要学习它们在网络数据测量、安全、及其它领域中的应用。 不但将掌握相关理论知识，而且要实现一部分算法，并在实际网络数据上应用。

- [紧凑数据结构与大数据 Compact Data Structures for Big Data](http://net.pku.edu.cn/~yangtong/pages/SummerForm18.html)
- [02951 Compact Data Structures](http://courses.compute.dtu.dk/02951/)
- http://latin2016.natix.org/wp-content/uploads/2016/04/tutorial.pdf
- http://fenris.cs.ucr.edu/pipermail/cpm-spire-l/2018-March/000457.html

## succinct data structures

In computer science, a succinct data structure is a data structure which uses an amount of space that is "close" to the information-theoretic lower bound, 
but (unlike other compressed representations) still allows for efficient query operations.

- https://www.cs.helsinki.fi/group/suds/
- http://simongog.github.io/
- http://algo2.iti.kit.edu/gog/homepage/index.html
- https://arxiv.org/abs/1904.02809
- https://github.com/simongog/sdsl-lite
- https://github.com/simongog/sdsl-lite/wiki/Literature
- https://github.com/simongog/sdsl-lite
- [Succinct Data Structures-Exploring succinct trees in theory and practice](http://www.eecs.tufts.edu/~aloupis/comp150/projects/SuccinctTreesinPractice.pdf)
- [Presentation "COBS: A Compact Bit-Sliced Signature Index" at SPIRE 2019 (Best Paper Award)](https://panthema.net/2019/1008-COBS-A-Compact-Bit-Sliced-Signature-Index/)